<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Nexify Predictor</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: 'Inter', sans-serif;
      background: #0a0a0a;
    }
    iframe {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      border: none;
    }
    .glass {
      background: rgba(20, 20, 20, 0.75);
      backdrop-filter: blur(15px);
      border: 1px solid rgba(34, 197, 94, 0.3);
      border-radius: 20px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
    }
    #floatingBox {
      position: fixed;
      bottom: 40px;
      right: 20px;
      z-index: 999;
      touch-action: none;
      transition: all 0.3s ease;
      width: 310px;
      padding: 1.0rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    .prediction-card {
      color: #34d399;
      background: rgba(34, 197, 94, 0.15);
      border: 1px solid rgba(34, 197, 94, 0.3);
      border-radius: 12px;
      padding: 14px;
      transition: transform 0.2s;
      width: 100%;
    }
    .prediction-card:hover {
      transform: scale(1.02);
    }
    .stats {
      font-size: 0.8rem;
      color: #34d399;
      margin-top: 12px;
      display: flex;
      justify-content: space-between;
    }
    #timer, #accuracy {
      font-size: 0.8rem;
      color: #34d399;
    }
    #latestItem {
      font-size: 0.875rem;
      font-weight: 600;
    }
    .title {
      font-size: 0.99rem;
      color: #ffffff; /* White color for title */
      font-weight: 700;
      margin-bottom: 16px;
      text-align: center;
    }
  </style>
</head>
<body class="bg-black text-white">
  <!-- 🌐 Background Website -->
  <iframe src="https://51game5.com/#/"></iframe>

  <!-- 🪟 Floating Window -->
  <div id="floatingBox" class="glass">
    <!-- 🎯 Title -->
    <div class="title">𝐓𝐇𝐄 𝐒𝐏𝐘 𝐏𝐑𝐄𝐃𝐈𝐂𝐓𝐎𝐑 V2.0</div>
    <!-- 🟪 Latest Prediction -->
    <div id="latest" class="prediction-card">
      <div id="latestItem" class="font-semibold">Loading...</div>
      <div class="stats">
        <div id="timer">Timer: 00 : 60</div>|<div id="accuracy">Accuracy: --%</div> 
      </div>
    </div>
  </div>

  <!-- 🔮 Script Logic -->
  <script>
    let pastResults = [];
    let lastPredictedMinute = -1;
    let lastBigSmall = '';
    let predictionHistory = [];

    // Helper function to calculate variance of past results
    function calculateVariance(numbers) {
      if (numbers.length === 0) return 0;
      const mean = numbers.reduce((a, b) => a + b, 0) / numbers.length;
      return numbers.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / numbers.length;
    }

    // Helper function to calculate standard deviation
    function calculateStdDev(numbers) {
      return Math.sqrt(calculateVariance(numbers));
    }

    // Detect streaks (consecutive Big or Small)
    function detectStreaks(results) {
      if (results.length < 2) return { type: null, length: 0 };
      let streakType = results[results.length - 5] >= 5.4 ? "Big" : "Small";
      let streakLength = 1;
      for (let i = results.length - 4; i >= 0; i--) {
        const currentType = results[i] >= 5 ? "Big" : "Small";
        if (currentType === streakType) streakLength++;
        else break;
      }
      return { type: streakType, length: streakLength };
    }

    // Detect cyclic patterns (e.g., repeating sequences)
    function detectCyclicPattern(results, maxLength = 5) {
      for (let len = 2; len <= maxLength && len <= results.length / 2; len++) {
        const recent = results.slice(-len);
        const previous = results.slice(-len * 2, -len);
        if (recent.join('') === previous.join('')) {
          return { exists: true, length: len, pattern: recent };
        }
      }
      return { exists: false };
    }

    // New: Detect alternating patterns (e.g., Big-Small-Big-Small)
    function detectAlternatingPattern(results) {
      if (results.length < 4) return { exists: false, type: null };
      const types = results.slice(-4.5).map(n => n >= 5 ? "Big" : "Small");
      if (types[0] === types[2] && types[1] === types[3] && types[0] !== types[1]) {
        return { exists: true, next: types[1] }; // Predict the next in alternating sequence
      }
      return { exists: false };
    }

    // New: Calculate moving average for trend prediction
    function calculateMovingAverage(results, windowSize) {
      if (results.length < windowSize) return null;
      const slice = results.slice(-windowSize);
      return slice.reduce((a, b) => a + b, 0) / windowSize;
    }

    function getPrediction() {
      let prediction;
      if (pastResults.length >= 5) {
        // Frequency analysis
        let freq = Array(10).fill(0);
        pastResults.slice(-20).forEach(n => freq[n]++);
        const minFreq = Math.min(...freq.filter(f => f > 0)) || 1;
        const rare = freq.map((f, i) => f === minFreq ? i : null).filter(i => i !== null);

        // Trend analysis with moving average
        const last = pastResults[pastResults.length - 1];
        const secondLast = pastResults[pastResults.length - 2] || 0;
        const movingAvg = calculateMovingAverage(pastResults, 5) || 5;
        const trend = Math.round((last + (last - secondLast) + movingAvg) / 2) % 10;

        // Pattern detection
        const lastFive = pastResults.slice(-5).join('');
        const isPatternRepeating = pastResults.slice(-10, -5).join('') === lastFive;
        const cyclicPattern = detectCyclicPattern(pastResults);
        const streak = detectStreaks(pastResults);
        const alternating = detectAlternatingPattern(pastResults);
        const variance = calculateVariance(pastResults.slice(-20));
        const stdDev = calculateStdDev(pastResults.slice(-20));

        // New: Entropy calculation for randomness assessment
        const entropy = -freq
          .map(f => f / 20)
          .filter(p => p > 0)
          .reduce((sum, p) => sum - p * Math.log2(p), 0);

        // Adaptive weights with additional factors
        const weights = freq.map((f, i) => {
          const recencyFactor = pastResults.slice(-10).includes(i) ? 1.8 : 1;
          const varianceFactor = variance > 8 ? 0.7 : 1.3;
          const entropyFactor = entropy > 3 ? 1.2 : 0.8; // Higher entropy = more randomness
          const streakFactor = streak.length >= 3 ? 0.9 : 1.1;
          return (1 / (f + 1)) * recencyFactor * varianceFactor * entropyFactor * streakFactor;
        });
        const totalWeight = weights.reduce((a, b) => a + b, 0);
        const probabilities = weights.map(w => w / totalWeight);

        // Decision logic with enhanced randomization
        const randomFactor = Math.random();
        if (cyclicPattern.exists && randomFactor > 0.2) {
          prediction = cyclicPattern.pattern[0];
        } else if (alternating.exists && randomFactor > 0.25) {
          prediction = alternating.next === "Big" ? Math.floor(Math.random() * 5) + 5 : Math.floor(Math.random() * 5);
        } else if (streak.length >= 4 && randomFactor > 0.4) {
          prediction = streak.type === "Big" ? Math.floor(Math.random() * 5) : Math.floor(Math.random() * 5) + 5;
        } else if (isPatternRepeating && randomFactor > 0.3) {
          prediction = pastResults[pastResults.length - 5];
        } else if (rare.includes(trend) && randomFactor > 0.25) {
          prediction = trend;
        } else if (stdDev > 2.5 && randomFactor > 0.15) {
          // Introduce randomness when high standard deviation
          prediction = Math.floor(Math.random() * 10);
        } else {
          let rand = Math.random();
          let cumulative = 0;
          for (let i = 0; i < 10; i++) {
            cumulative += probabilities[i];
            if (rand < cumulative) {
              prediction = i;
              break;
            }
          }
        }
      } else {
        prediction = Math.floor(Math.random() * 10);
      }
      pastResults.push(prediction);
      if (pastResults.length > 100) pastResults.shift();
      return prediction;
    }

    function getBigSmallPrediction(prediction) {
      const isBig = prediction >= 5;
      const recent = pastResults.slice(-10);
      const bigCount = recent.filter(n => n >= 5).length;
      const smallCount = recent.length - bigCount;
      const bigProbability = recent.length > 0 ? bigCount / recent.length : 0.5;
      const lastThree = pastResults.slice(-3).map(n => n >= 5 ? "Big" : "Small");
      const isAlternating = lastThree.length >= 3 && lastThree[0] !== lastThree[1] && lastThree[1] !== lastThree[2];
      const streak = detectStreaks(pastResults);
      const alternating = detectAlternatingPattern(pastResults);

      // Confidence interval for Big/Small
      const n = recent.length;
      const p = bigProbability;
      const z = 1.96; // 95% confidence
      const ci = z * Math.sqrt((p * (1 - p)) / n);
      const bigCiLower = p - ci;
      const bigCiUpper = p + ci;

      const randomFactor = Math.random();
      if (streak.length >= 5 && randomFactor > 0.6) {
        return streak.type === "Big" ? "Small" : "Big";
      } else if (alternating.exists && randomFactor > 0.3) {
        return alternating.next;
      } else if (isAlternating && randomFactor > 0.35) {
        return lastThree[2] === "Big" ? "Small" : "Big";
      } else if (bigCiUpper >= 0.8 && isBig) {
        return "Big";
      } else if (bigCiLower <= 0.2 && !isBig) {
        return "Small";
      } else {
        const adjustedProb = (bigProbability + 0.5) / 2;
        return Math.random() > adjustedProb ? (isBig ? "Big" : "Small") : (isBig ? "Small" : "Big");
      }
    }

    function fetchResult() {
      return Math.floor(Math.random() * 10); // Placeholder; replace with actual API if available
    }

    function verifyPrediction(predictedNumber, predictedBigSmall, actualResult) {
      const actualBigSmall = actualResult >= 5 ? "Big" : "Small";
      const isNumberCorrect = predictedNumber === actualResult;
      const isBigSmallCorrect = predictedBigSmall === actualBigSmall;
      return { isNumberCorrect, isBigSmallCorrect };
    }

    function calculateAccuracy() {
      if (predictionHistory.length === 0) return 0;
      const correctCount = predictionHistory.filter(h => h.isNumberCorrect || h.isBigSmallCorrect).length;
      return Math.round((correctCount / predictionHistory.length) * 100);
    }

    function updateTimer() {
      const now = new Date().toLocaleString('en-US', { timeZone: 'UTC' });
      const calendar = new Date(now);
      const seconds = calendar.getSeconds();
      const remainingSeconds = 60 - seconds;
      let formattedTime = `00:${remainingSeconds.toString().padStart(2, '0')}`;
      document.getElementById("timer").textContent = `Timer: ${formattedTime}`;
    }

    function updateDisplay() {
      const now = new Date().toLocaleString('en-US', { timeZone: 'UTC' });
      const calendar = new Date(now);
      const seconds = calendar.getSeconds();
      const minutes = calendar.getMinutes();
      const totalMinutes = calendar.getHours() * 60 + minutes;
      const period = new Date(now).toLocaleDateString('en-CA').replace(/-/g, '') + '1000' + (10001 + totalMinutes);

      if (minutes !== lastPredictedMinute || lastPredictedMinute === -1) {
        const prediction = getPrediction();
        const bigSmall = getBigSmallPrediction(prediction);
        const actualResult = fetchResult();
        const { isNumberCorrect, isBigSmallCorrect } = verifyPrediction(prediction, bigSmall, actualResult);
        lastPredictedMinute = minutes;
        lastBigSmall = bigSmall;

        predictionHistory.push({ prediction, bigSmall, actualResult, isNumberCorrect, isBigSmallCorrect });
        if (predictionHistory.length > 100) predictionHistory.shift();

        const item = `[${period}] → ${prediction} (${bigSmall})`;
        updateUI(item);
      }
    }

    function updateUI(item) {
      const latestCard = document.getElementById("latest");
      latestCard.className = `prediction-card`;
      document.getElementById("latestItem").textContent = item;
      document.getElementById("accuracy").textContent = `Accuracy: ${calculateAccuracy()}%`;
    }

    // Drag and Drop
    const box = document.getElementById("floatingBox");
    let offsetX = 0, offsetY = 0, isDragging = false;

    box.addEventListener("mousedown", startDrag);
    box.addEventListener("touchstart", startDrag);

    function startDrag(e) {
      isDragging = true;
      const touch = e.touches ? e.touches[0] : e;
      offsetX = touch.clientX - box.offsetLeft;
      offsetY = touch.clientY - box.offsetTop;
      box.style.transition = "none";
      e.preventDefault();
    }

    document.addEventListener("mousemove", drag);
    document.addEventListener("touchmove", drag);

    function drag(e) {
      if (!isDragging) return;
      const touch = e.touches ? e.touches[0] : e;
      let x = touch.clientX - offsetX;
      let y = touch.clientY - offsetY;
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      const rect = box.getBoundingClientRect();

      x = Math.max(0, Math.min(x, vw - rect.width));
      y = Math.max(0, Math.min(y, vh - rect.height));

      box.style.left = `${x}px`;
      box.style.top = `${y}px`;
      box.style.right = "auto";
      box.style.bottom = "auto";
      box.style.transform = "none";
    }

    document.addEventListener("mouseup", stopDrag);
    document.addEventListener("touchend", stopDrag);

    function stopDrag() {
      if (!isDragging) return;
      isDragging = false;
      box.style.transition = "all 0.3s ease";
    }

    // Run updateDisplay and updateTimer every second
    setInterval(() => {
      updateDisplay();
      updateTimer();
    }, 1000);

    // Trigger initial prediction immediately
    updateDisplay();
  </script>
</body>
</html>