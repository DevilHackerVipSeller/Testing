<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>𝐃𝐄𝐕𝐈𝐋 𝐇𝐀𝐂𝐊𝐄𝐑 𝐅𝐀𝐌𝐈𝐋𝐘</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;500;700&amp;family=Orbitron:wght@400;600&amp;display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
    @keyframes gradientShift { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } }
    @keyframes ripple { 0% { transform: scale(0); opacity: 0.5; } 100% { transform: scale(4); opacity: 0; } }

    .ripple-button {
      position: relative;
      overflow: hidden;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    .ripple-button:hover {
      transform: translateY(-3px);
      box-shadow: 0 6px 16px rgba(45, 212, 191, 0.3);
    }
    .ripple-button:active {
      transform: scale(0.98);
    }
    .ripple-button::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(45, 212, 191, 0.4);
      border-radius: 50%;
      transform: scale(0);
      opacity: 0;
      pointer-events: none;
      z-index: 1;
    }
    .ripple-button.ripple-effect::after {
      animation: ripple 0.5s ease-out;
    }

    body {
      background: linear-gradient(to right, #1E1B4B, #2E1065, #1E1B4B);
      background-size: 200% 200%;
      animation: gradientShift 20s ease infinite;
      font-family: 'Poppins', sans-serif;
      color: #F5F5F5;
      min-h-screen;
      padding: 1.5rem;
    }

    .container {
      max-width: 28rem;
      margin: 0 auto;
      padding: 0 0.5rem;
    }

    .wrapper svg {
      width: 100%;
      height: 100%;
      max-height: 60px;
      filter: drop-shadow(0 0 8px rgba(45, 212, 191, 0.4));
    }
    .wrapper svg text {
      font-size: 10px;
      font-family: 'Orbitron', sans-serif;
      fill: #2DD4BF;
      stroke: #F472B6;
      stroke-width: 0.5;
      text-shadow: 0 0 12px rgba(45, 212, 191, 0.5);
      animation: pulse 2s ease-in-out infinite;
    }

    .toast {
      position: fixed;
      top: 1rem;
      right: 1rem;
      left: 1rem;
      background: rgba(30, 27, 75, 0.95);
      color: #2DD4BF;
      padding: 0.75rem 1rem;
      border-radius: 0.5rem;
      border: 1px solid #2DD4BF;
      opacity: 0;
      transition: opacity 0.3s ease;
      z-index: 1000;
      box-shadow: 0 4px 12px rgba(45, 212, 191, 0.2);
      font-size: 0.875rem;
      text-align: center;
    }
    .toast.show { opacity: 1; }

    .card {
      background: linear-gradient(135deg, #2E1065, #1E1B4B);
      border-radius: 0.75rem;
      border: 1px solid rgba(45, 212, 191, 0.2);
      padding: 1rem;
      margin-bottom: 1.5rem;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    .card:hover {
      transform: translateY(-4px);
      box-shadow: 0 8px 20px rgba(45, 212, 191, 0.3);
    }

    .gradient-button {
      background: linear-gradient(to right, #2DD4BF, #F472B6);
      border: none;
      border-radius: 0.5rem;
      padding: 0.5rem 1rem;
      font-size: 0.875rem;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: #1E1B4B;
      box-shadow: 0 4px 12px rgba(45, 212, 191, 0.3);
      transition: all 0.3s ease;
    }
    .gradient-button:hover {
      background: linear-gradient(to right, #F472B6, #2DD4BF);
      box-shadow: 0 6px 16px rgba(45, 212, 191, 0.5);
      transform: translateY(-2px);
    }

    .history-item {
      background: linear-gradient(135deg, #2E1065, #1E1B4B);
      border-radius: 0.5rem;
      padding: 0.75rem;
      transition: all 0.3s ease;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }
    .history-item:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(45, 212, 191, 0.25);
    }

    .no-results {
      border: 2px solid #F87171;
      text-align: center;
      color: #F87171;
      padding: 0.75rem;
      border-radius: 0.5rem;
      font-size: 0.875rem;
    }

    .panel {
      background: rgba(30, 27, 75, 0.9);
      border-radius: 0.5rem;
      padding: 0.75rem;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }

    @media (max-width: 640px) {
      .container { padding: 0 0.5rem; }
      .wrapper svg text { font-size: 8px; }
      .card { padding: 0.75rem; }
      .toast { top: 0.75rem; font-size: 0.75rem; }
      .gradient-button { font-size: 0.75rem; padding: 0.4rem 0.8rem; }
    }
  </style>
 </head>
 <body class="min-h-screen p-4">
  <div class="container space-y-6">
   <div class="wrapper">
    <svg role="img" viewBox="0 0 10 20" preserveAspectRatio="xMidYMid meet">
     <text x="50%" y="50%" dy=".1em" text-anchor="middle" font-size="80"> 𝐃𝐄𝐕𝐈𝐋 𝐇𝐀𝐂𝐊𝐄𝐑 𝐅𝐀𝐌𝐈𝐋𝐘 </text>
    </svg>
   </div>
   <div class="card">
    <div class="flex items-center justify-between mb-3">
     <h2 class="text-lg font-bold text-teal-400 flex items-center font-orbitron"><i class="fa-solid fa-brain mr-2"></i> Current Predictor</h2><button onclick="refreshPrediction()" class="ripple-button gradient-button font-semibold flex items-center"> <i class="fa-solid fa-sync-alt mr-1"></i> Refresh </button>
    </div>
    <div class="panel text-center">
     <div class="text-teal-300 mb-2 text-sm">
      PERIOD: <span id="currentPeriodDisplay">-</span>
     </div>
     <div class="text-teal-300 mb-2 text-sm">
      TIMER: <span id="timerDisplay">0 0 : 0 0</span>
     </div>
     <div id="currentPredictionDisplay" class="text-xl font-bold text-white mb-1">
      -
     </div>
     <div class="text-white text-sm">
      CONFIDENCE: <span id="confidenceDisplay">0%</span>
     </div>
    </div>
   </div>
   <div class="card">
    <h2 class="text-lg font-bold text-teal-400 mb-3 font-orbitron">══✿ Analysis Dashboard ✿══</h2>
    <div class="grid grid-cols-2 gap-3">
     <div class="panel text-center">
      <div class="text-teal-300 text-sm">
       Total Wins
      </div>
      <div id="totalWins" class="text-lg font-bold text-white">
       0
      </div>
     </div>
     <div class="panel text-center">
      <div class="text-teal-300 text-sm">
       Total Losses
      </div>
      <div id="totalLosses" class="text-lg font-bold text-white">
       0
      </div>
     </div>
     <div class="panel text-center">
      <div class="text-teal-300 text-sm">
       CONFIDENCE
      </div>
      <div id="overallConfidenceDisplay" class="text-white">
       0%
      </div>
     </div>
     <div class="panel text-center">
      <div class="text-teal-300 text-sm">
       Server Status
      </div>
      <div id="serverStatus" class="text-lg font-bold text-white">
       Connecting
      </div>
     </div>
    </div>
   </div>
   <div class="card">
    <h2 class="text-lg font-bold text-teal-400 mb-3 font-orbitron">━━━━━━◆ History ◆━━━━━━</h2>
    <div id="historyContainer" class="space-y-3"></div>
   </div>
  </div>
  <div id="toastContainer" class="toast"></div>
  <script>
// Configuration Constants
const API_URL = "https://api.fantasygamesapi.com/api/webapi/GetNoaverageEmerdList";
const API_RETRY_INTERVAL = 5000;
const API_MAX_RETRIES = 3;
const UPDATE_INTERVAL = 5000;
const SMALL_NUMBERS = [0, 1, 2, 3, 4];
const BIG_NUMBERS = [5, 6, 7, 8, 9];
const MAX_HISTORY = 50;
const TOAST_COOLDOWN = 1500;

// DOM Elements Cache
const DOM = {
  toastContainer: document.getElementById("toastContainer"),
  currentPeriodDisplay: document.getElementById("currentPeriodDisplay"),
  timerDisplay: document.getElementById("timerDisplay"),
  currentPredictionDisplay: document.getElementById("currentPredictionDisplay"),
  confidenceDisplay: document.getElementById("confidenceDisplay"),
  totalWins: document.getElementById("totalWins"),
  totalLosses: document.getElementById("totalLosses"),
  overallConfidenceDisplay: document.getElementById("overallConfidenceDisplay"),
  serverStatus: document.getElementById("serverStatus"),
  historyContainer: document.getElementById("historyContainer"),
  resetButton: document.getElementById("resetButton")
};

// Validate DOM elements
Object.values(DOM).forEach((el, index) => {
  if (!el && index !== 8) console.error(`DOM element at index ${index} is null. Check HTML IDs.`);
});

// State
let historyData = JSON.parse(localStorage.getItem('spyPredictorHistory')) || [];
let lastFetchedPeriod = null;
let lastPrediction = null;
let stats = JSON.parse(localStorage.getItem('spyPredictorStats')) || { wins: 0, losses: 0 };
let isFetching = false;
let lastPeriodUpdate = null;
let lastToastTime = 0;

// Utility Functions
const showToast = (message, type = "info", duration = 1500) => {
  const now = Date.now();
  if (now - lastToastTime < TOAST_COOLDOWN) return;
  lastToastTime = now;
  if (!DOM.toastContainer) return console.error("Toast container not found");
  DOM.toastContainer.textContent = message;
  DOM.toastContainer.className = `toast show ${type}`;
  setTimeout(() => DOM.toastContainer.className = "toast", duration);
};

const formatPeriodNumber = () => {
  const now = new Date();
  now.setTime(now.getTime() + (now.getTimezoneOffset() + 5.5 * 60) * 60 * 1000);
  const yearMonthDay = now.toISOString().slice(0, 10).replace(/-/g, '');
  const minutes = now.getHours() * 60 + now.getMinutes();
  return yearMonthDay + "1000" + (10001 + minutes).toString();
};

const pad = (num) => num.toString().padStart(2, '0');

const formatTimer = () => {
  const now = new Date();
  now.setTime(now.getTime() + (now.getTimezoneOffset() + 5.5 * 60) * 60 * 1000);
  const seconds = now.getSeconds();
  const remainingSeconds = 60 - seconds;
  return `${pad(0)} : ${pad(remainingSeconds)}`.replace(/(\d)(?=\d)/g, '$1 ');
};

const getBetLevel = (confidence) => {
  if (confidence >= 95) return "4x";
  if (confidence >= 85) return "3x";
  if (confidence >= 70) return "2x";
  return "1x";
};

// Advanced Real-Time AI Prediction Logic
const spyPredict = (history) => {
  console.log("spyPredict called with history:", history);
  if (history.length < 5) {
    const prediction = history.length > 0 ? (Number(history[0].result) >= 5 ? "SMALL" : "BIG") : "BIG"; // Avoid randomization
    return {
      predictions: Array(10).fill({ prediction, confidence: 50, betLevel: "1x", reasoning: "Default prediction (insufficient data)" }),
      decisionFactor: "Default prediction (insufficient data)"
    };
  }

  // Filter valid results
  const recentResults = history
    .filter(h => h.result !== "-" && !isNaN(Number(h.result)) && Number(h.result) >= 0 && Number(h.result) <= 9)
    .slice(0, 20)
    .map(h => Number(h.result))
    .reverse();

  if (recentResults.length < 5) {
    const prediction = recentResults.length > 0 ? (recentResults[0] >= 5 ? "SMALL" : "BIG") : "BIG";
    return {
      predictions: Array(10).fill({ prediction, confidence: 50, betLevel: "1x", reasoning: "Default prediction (no valid historical data)" }),
      decisionFactor: "Default prediction (no valid historical data)"
    };
  }

  // Initialize variables
  let predictions = [];
  let simulatedHistory = [...recentResults];
  let decisionFactors = [];

  // Helper function for one-step prediction
  const predictOneStep = (currentHistory) => {
    let prediction = "BIG";
    let confidence = 50;
    let reasoning = [];

    // 1. Second-Order Markov Chain (Prompt 1: Pattern Detection)
    const transitions = {
      BB_B: 0, BB_S: 0, BS_B: 0, BS_S: 0,
      SB_B: 0, SB_S: 0, SS_B: 0, SS_S: 0
    };
    let totalTransitions = 0;
    for (let i = 2; i < currentHistory.length; i++) {
      const prev2 = currentHistory[i - 2] >= 5 ? "B" : "S";
      const prev1 = currentHistory[i - 1] >= 5 ? "B" : "S";
      const curr = currentHistory[i] >= 5 ? "B" : "S";
      transitions[`${prev2}${prev1}_${curr}`]++;
      totalTransitions++;
    }
    const getTransitionProb = (prev2, prev1) => {
      const total = transitions[`${prev2}${prev1}_B`] + transitions[`${prev2}${prev1}_S`] || 1;
      return transitions[`${prev2}${prev1}_B`] / total || 0.5;
    };
    const last2Type = currentHistory[1] >= 5 ? "B" : "S";
    const last1Type = currentHistory[0] >= 5 ? "B" : "S";
    const markovScore = getTransitionProb(last2Type, last1Type);
    reasoning.push(`Markov P(${last2Type}${last1Type}→B): ${markovScore.toFixed(2)}`);

    // 2. Entropy Analysis (Prompt 3: Probability Analysis)
    const bigCount = currentHistory.filter(num => num >= 5).length;
    const totalCount = currentHistory.length;
    const probBig = bigCount / totalCount;
    const probSmall = 1 - probBig;
    const entropy = -(probBig * Math.log2(probBig + 1e-10) + probSmall * Math.log2(probSmall + 1e-10));
    const entropyThreshold = currentHistory.length < 10 ? 0.98 : 0.95;
    const isHighEntropy = entropy > entropyThreshold;
    reasoning.push(`Entropy: ${entropy.toFixed(2)}, Prob Big: ${probBig.toFixed(2)}`);

    // 3. Trend Analysis (Prompt 2: Trend-Based Forecasting)
    const recent20 = currentHistory.slice(0, 20);
    const consecutiveBigs = recent20.reduce((acc, num, i) => {
      if (i > 0 && num >= 5 && recent20[i - 1] >= 5) acc++;
      return acc;
    }, 0);
    const consecutiveSmalls = recent20.reduce((acc, num, i) => {
      if (i > 0 && num < 5 && recent20[i - 1] < 5) acc++;
      return acc;
    }, 0);
    const trendScore = consecutiveBigs > consecutiveSmalls ? 0.6 : consecutiveSmalls > consecutiveBigs ? 0.4 : 0.5;
    reasoning.push(`Trend: ${consecutiveBigs > consecutiveSmalls ? "BIG" : consecutiveSmalls > consecutiveBigs ? "SMALL" : "Neutral"} (Big: ${consecutiveBigs}, Small: ${consecutiveSmalls})`);

    // 4. Streak Analysis (Prompt 4: Statistical Modeling)
    let streakType = null;
    let streakLength = 1;
    let anomalyScore = 0;
    for (let i = 1; i < currentHistory.length; i++) {
      const currentType = currentHistory[i] >= 5 ? "BIG" : "SMALL";
      const prevType = currentHistory[i - 1] >= 5 ? "BIG" : "SMALL";
      if (currentType === prevType) {
        streakLength++;
        streakType = currentType;
      } else {
        break;
      }
    }
    if (streakLength >= 5) anomalyScore = 0.3; // Detect anomaly for long streaks
    const streakThreshold = currentHistory.length < 10 ? 3 : 4;
    reasoning.push(`Streak: ${streakType || "None"} (${streakLength})${anomalyScore > 0 ? ", Anomaly detected" : ""}`);

    // 5. Alternation Analysis (Prompt 2: Trend-Based Forecasting)
    let alternationCount = 0;
    for (let i = 2; i < currentHistory.length; i++) {
      const type1 = currentHistory[i] >= 5 ? "B" : "S";
      const type2 = currentHistory[i - 1] >= 5 ? "B" : "S";
      const type3 = currentHistory[i - 2] >= 5 ? "B" : "S";
      if (type1 !== type2 && type2 !== type3) alternationCount++;
    }
    const alternationRatio = alternationCount / (currentHistory.length - 2) || 0;
    reasoning.push(`Alternation ratio: ${alternationRatio.toFixed(2)}`);

    // 6. Sequence Pattern Detection (Prompt 5: Sequence-Based Prediction)
    let cycleLength = 0;
    for (let len = 2; len <= 6; len++) {
      let isCycle = true;
      for (let i = len; i < currentHistory.length && i < len * 2; i++) {
        if ((currentHistory[i] >= 5) !== (currentHistory[i - len] >= 5)) {
          isCycle = false;
          break;
        }
      }
      if (isCycle && currentHistory.length >= len * 2) {
        cycleLength = len;
        break;
      }
    }
    const cycleScore = cycleLength > 0 ? 0.6 : 0.5;
    reasoning.push(`Cycle length: ${cycleLength || "None"}`);

    // 7. Temporal Pattern Reinforcement
    const now = new Date();
    now.setTime(now.getTime() + (now.getTimezoneOffset() + 5.5 * 60) * 60 * 1000);
    const minuteOfHour = now.getMinutes();
    const isFirstHalf = minuteOfHour < 30;
    let timeBias = isFirstHalf ? 0.55 : 0.45;
    const minuteHistory = history.filter(h => h.period.slice(-2) === pad(minuteOfHour));
    if (minuteHistory.length >= 5) {
      const minuteBigCount = minuteHistory.filter(h => Number(h.result) >= 5).length;
      timeBias = minuteBigCount / minuteHistory.length;
    }
    reasoning.push(`Time bias: ${isFirstHalf ? "BIG" : "SMALL"} (${timeBias.toFixed(2)})`);

    // 8. Real-Time AI Adaptive Learning (Prompt 6)
    let winRate = 0.5;
    let learningRate = 0.1;
    let signalWeights = { markov: 0.25, trend: 0.2, prob: 0.15, streak: 0.15, alternation: 0.1, cycle: 0.1, time: 0.05 };
    if (history.length >= 10) {
      const recentPredictions = history.slice(0, 10).filter(h => h.resultStatus === "WIN");
      winRate = recentPredictions.length / 10;
      learningRate = winRate > 0.7 ? 0.15 : winRate < 0.3 ? 0.05 : 0.1;
      // Adjust signal weights based on performance
      signalWeights.markov = winRate > 0.7 ? 0.3 : winRate < 0.3 ? 0.2 : 0.25;
      signalWeights.trend = winRate > 0.7 ? 0.25 : winRate < 0.3 ? 0.15 : 0.2;
      reasoning.push(`Win rate: ${winRate.toFixed(2)}, Learning rate: ${learningRate.toFixed(2)}, Signal weights: ${JSON.stringify(signalWeights)}`);
    }

    // Decision Logic
    let scoreBig = 0;
    let scoreSmall = 0;

    // Combine signals
    scoreBig += markovScore * signalWeights.markov;
    scoreSmall += (1 - markovScore) * signalWeights.markov;
    scoreBig += trendScore * signalWeights.trend;
    scoreSmall += (1 - trendScore) * signalWeights.trend;
    scoreBig += probBig * signalWeights.prob;
    scoreSmall += probSmall * signalWeights.prob;
    scoreBig += timeBias * signalWeights.time;
    scoreSmall += (1 - timeBias) * signalWeights.time;
    scoreBig += cycleScore * signalWeights.cycle;
    scoreSmall += (1 - cycleScore) * signalWeights.cycle;
    if (streakLength >= streakThreshold) {
      if (streakType === "BIG") scoreSmall += signalWeights.streak + anomalyScore;
      else scoreBig += signalWeights.streak + anomalyScore;
    } else if (streakLength >= 2) {
      if (streakType === "BIG") scoreBig += signalWeights.streak / 2;
      else scoreSmall += signalWeights.streak / 2;
    }
    if (alternationRatio > 0.65) {
      const lastType = currentHistory[0] >= 5 ? "BIG" : "SMALL";
      if (lastType === "BIG") scoreSmall += signalWeights.alternation;
      else scoreBig += signalWeights.alternation;
    }
    scoreBig += winRate * learningRate;
    scoreSmall += (1 - winRate) * learningRate;

    // Entropy adjustment
    const entropyFactor = isHighEntropy ? 0.4 : 1.0;
    scoreBig *= entropyFactor;
    scoreSmall *= entropyFactor;

    // Normalize scores
    const totalScore = scoreBig + scoreSmall;
    if (totalScore > 0) {
      scoreBig /= totalScore;
      scoreSmall /= totalScore;
    }

    // Final prediction
    prediction = scoreBig >= scoreSmall ? "BIG" : "SMALL";
    confidence = Math.round(Math.max(scoreBig, scoreSmall) * 100);
    confidence = Math.min(95, confidence + winRate * 15); // Cap at 95%
    if (isHighEntropy) {
      confidence = Math.max(50, confidence * 0.7);
      reasoning.push("Confidence reduced due to high entropy");
    }

    const betLevel = getBetLevel(confidence);
    return { prediction, confidence, betLevel, reasoning: reasoning.join(", ") };
  };

  // Predict next 10 outcomes
  for (let i = 0; i < 10; i++) {
    const result = predictOneStep(simulatedHistory);
    predictions.push(result);
    simulatedHistory.unshift(result.prediction === "BIG" ? 5 : 0); // Simulate next result
  }

  const decisionFactor = predictions[0].reasoning;
  console.log("Predictions:", predictions);
  return { predictions, decisionFactor };
};

const updateLastStatus = (actualNumber) => {
  console.log("updateLastStatus called with actualNumber:", actualNumber, "lastPrediction:", lastPrediction);
  if (!lastPrediction) return "Pending";
  const actualType = actualNumber >= 5 ? "BIG" : "SMALL";
  const status = lastPrediction === actualType ? "WIN" : "LOSS";
  stats[status === "WIN" ? "wins" : "losses"]++;
  localStorage.setItem('spyPredictorStats', JSON.stringify(stats));
  console.log("Updated stats:", stats);
  return status;
};

const saveHistory = () => {
  historyData = historyData.slice(0, MAX_HISTORY);
  try {
    localStorage.setItem('spyPredictorHistory', JSON.stringify(historyData));
    console.log("History saved:", historyData);
  } catch (e) {
    showToast("Warning: Failed to save history.", "warning");
    console.error("History save error:", e);
  }
};

const fetchGameResult = async (retryCount = 0) => {
  if (isFetching) {
    console.log("Fetch skipped: already fetching");
    return null;
  }
  isFetching = true;
  DOM.serverStatus.innerText = `Connecting (Attempt ${retryCount + 1})`;
  DOM.currentPredictionDisplay.innerHTML = '<i class="fa fa-spinner spinner"></i>';
  try {
    const response = await fetch(API_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        pageSize: 10,
        pageNo: 1,
        typeId: 1,
        language: 0,
        random: "4a0522c6ecd8410496260e686be2a57c",
        signature: "334B5E70A0C9B8918B0B15E517E2069C",
        timestamp: Math.floor(Date.now() / 1000)
      })
    });
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    console.log("Raw API response:", data);
    if (!data?.data?.list?.length || !data.data.list[0].issueNumber || !data.data.list[0].number || isNaN(Number(data.data.list[0].number)) || Number(data.data.list[0].number) < 0 || Number(data.data.list[0].number) > 9) {
      throw new Error("Invalid API response: empty list or missing/invalid issueNumber/number");
    }
    DOM.serverStatus.innerText = "Connected";
    showToast("Fetched game data.", "success");
    console.log("API Result:", data.data.list[0]);
    return data.data.list[0];
  } catch (e) {
    console.error("API Error:", e.message, "Retry count:", retryCount);
    DOM.serverStatus.innerText = `Retry ${retryCount + 1}/${API_MAX_RETRIES}`;
    if (retryCount < API_MAX_RETRIES) {
      await new Promise(resolve => setTimeout(resolve, API_RETRY_INTERVAL));
      return fetchGameResult(retryCount + 1);
    } else {
      showToast("API failed. Using simulated data.", "error");
      console.warn("Using simulated data");
      const simulatedResult = {
        issueNumber: formatPeriodNumber(),
        number: (historyData[0]?.result >= 5 ? "0" : "5") // Avoid randomization, use opposite of last
      };
      console.log("Simulated Result:", simulatedResult);
      DOM.serverStatus.innerText = "Simulated";
      return simulatedResult;
    }
  } finally {
    isFetching = false;
  }
};

const updatePrediction = async () => {
  console.log("updatePrediction called at", new Date().toISOString());
  const now = new Date();
  now.setTime(now.getTime() + (now.getTimezoneOffset() + 5.5 * 60) * 60 * 1000);
  const currentMinute = now.getHours() * 60 + now.getMinutes();
  const result = await fetchGameResult();

  if (!result) {
    console.warn("No result fetched, updating UI with existing data");
    showToast("No new data available.", "warning");
    DOM.currentPredictionDisplay.innerText = lastPrediction ? `${lastPrediction} (1x)` : "Waiting for data...";
    updateHistory();
    updateStats();
    return;
  }

  console.log("Fetched result:", result);

  // Calculate next period
  const nextPeriodFull = (BigInt(result.issueNumber) + 1n).toString();
  const nextPeriod = nextPeriodFull.slice(-3);

  // Prevent duplicate periods
  if (lastFetchedPeriod === result.issueNumber && lastPeriodUpdate === currentMinute) {
    console.log("Duplicate period detected, skipping update");
    DOM.currentPredictionDisplay.innerText = lastPrediction ? `${lastPrediction} (1x)` : "Waiting for data...";
    updateHistory();
    updateStats();
    return;
  }

  // Cross-check period to ensure no duplicates
  if (historyData.some(item => item.period === nextPeriod)) {
    console.log("Next period already in history, refreshing UI");
    DOM.currentPredictionDisplay.innerText = lastPrediction ? `${lastPrediction} (1x)` : "Waiting for data...";
    updateHistory();
    updateStats();
    return;
  }

  // Update previous period if pending
  if (historyData.length > 0 && historyData[0].resultStatus === "Pending") {
    const actualNumber = Number(result.number);
    if (isNaN(actualNumber)) {
      console.error("Invalid result number:", result.number);
      showToast("Error: Invalid API result number.", "error");
      updateHistory();
      updateStats();
      return;
    }
    const status = updateLastStatus(actualNumber);
    const resultType = actualNumber >= 5 ? "BIG" : "SMALL";
    historyData[0].result = actualNumber.toString();
    historyData[0].resultStatus = status;
    historyData[0].calculation = `${actualNumber} (${resultType})`;
    showToast(`Result: ${status} (${resultType})`, status === "WIN" ? "success" : "error");
    saveHistory();
    updateHistory();
    updateStats();
  }

  // Generate new predictions
  const aiDecision = spyPredict(historyData);
  lastPrediction = aiDecision.predictions[0].prediction;

  // Update UI with first prediction
  DOM.currentPeriodDisplay.innerText = nextPeriodFull;
  DOM.currentPredictionDisplay.innerText = `${aiDecision.predictions[0].prediction} (${aiDecision.predictions[0].betLevel})`;
  DOM.confidenceDisplay.innerText = `${aiDecision.predictions[0].confidence}%`;
  DOM.overallConfidenceDisplay.innerText = `${aiDecision.predictions[0].confidence}%`;

  // Store first prediction in history
  historyData.unshift({
    period: nextPeriod,
    prediction: aiDecision.predictions[0].prediction,
    betLevel: aiDecision.predictions[0].betLevel,
    result: "-",
    resultStatus: "Pending",
    calculation: "-",
    decisionFactor: aiDecision.decisionFactor
  });
  saveHistory();
  updateHistory();
  updateStats();
  lastFetchedPeriod = result.issueNumber;
  lastPeriodUpdate = currentMinute;

  // Log next 10 predictions
  console.log("Next 10 predictions:", aiDecision.predictions.map((p, i) => ({
    Period: (BigInt(nextPeriodFull) + BigInt(i)).toString().slice(-3),
    Prediction: p.prediction,
    Confidence: `${p.confidence}%`,
    BetLevel: p.betLevel,
    Reasoning: p.reasoning
  })));
};

const updateTimer = () => {
  DOM.timerDisplay.innerText = formatTimer();
  requestAnimationFrame(updateTimer);
};

const updateStats = () => {
  DOM.totalWins.innerText = stats.wins || 0;
  DOM.totalLosses.innerText = stats.losses || 0;
  console.log("Stats updated:", stats);
};

const updateHistory = () => {
  console.log("Updating history with data:", JSON.stringify(historyData, null, 2));
  if (!DOM.historyContainer) {
    console.error("History container not found");
    showToast("Error: History container not found.", "error");
    return;
  }
  if (historyData.length === 0) {
    console.warn("No history data available");
    DOM.historyContainer.innerHTML = '<div class="no-results">No results available yet. Waiting for API data...</div>';
    return;
  }
  try {
    DOM.historyContainer.innerHTML = historyData.map((item, index) => {
      let borderColor = item.resultStatus === "WIN" ? "border-l-4 border-green-400" :
                       item.resultStatus === "LOSS" ? "border-l-4 border-red-400" :
                       "border-l-4 border-yellow-400";
      let iconClass = item.resultStatus === "WIN" ? "fa-check-circle win-animation text-green-400" :
                      item.resultStatus === "LOSS" ? "fa-xmark-circle loss-animation text-red-400" :
                      "fa-spinner spinner text-yellow-400";
      return `<div class="history-item ripple grid grid-cols-3 gap-2 p-3 ${borderColor}" role="listitem">
                <div class="col-span-2 space-y-1">
                  <div class="text-cyan-200 text-sm"><i class="fa fa-calendar mr-1 text-magenta-400"></i><strong>Period: ${item.period}</strong></div>
                  <div class="text-cyan-200 text-sm"><i class="fa fa-money-bill mr-1 text-magenta-400"></i>Predict: ${item.prediction} (${item.betLevel})</div>
                  <div class="text-cyan-200 text-sm"><i class="fa fa-chart-bar mr-1 text-magenta-400"></i>Result: ${item.calculation}</div>
                  <div class="text-cyan-200 text-sm"><i class="fa fa-trophy mr-1 text-magenta-400"></i>Status: ${item.resultStatus}</div>
                </div>
                <div class="flex items-center justify-end">
                  <i class="fa-solid ${iconClass} text-lg"></i>
                  <button onclick="deleteHistoryItem(${index})" class="ml-2 text-red-600 hover:text-red-800" title="Delete">
                    <i class="fa-solid fa-trash"></i>
                  </button>
                </div>
              </div>`;
    }).join('');
  } catch (e) {
    console.error("Error updating history:", e);
    showToast("Error updating history display.", "error");
    DOM.historyContainer.innerHTML = '<div class="no-results">Error displaying history.</div>';
  }
};

const refreshPrediction = async () => {
  showToast("Refreshing prediction...", "info");
  await updatePrediction();
};

const clearHistory = () => {
  historyData = [];
  stats.wins = 0;
  stats.losses = 0;
  saveHistory();
  localStorage.setItem('spyPredictorStats', JSON.stringify(stats));
  updateHistory();
  updateStats();
  showToast("History cleared.", "success");
};

const deleteHistoryItem = (index) => {
  if (index < 0 || index >= historyData.length) {
    showToast("Error: Invalid history item.", "error");
    return;
  }
  const item = historyData[index];
  if (item.resultStatus === "WIN") stats.wins--;
  else if (item.resultStatus === "LOSS") stats.losses--;
  historyData.splice(index, 1);
  saveHistory();
  localStorage.setItem('spyPredictorStats', JSON.stringify(stats));
  updateHistory();
  updateStats();
  showToast("History item deleted.", "success");
};

// Initialize
const init = () => {
  console.log("Initializing application at", new Date().toISOString());
  clearHistory();
  updateTimer();
  setInterval(updatePrediction, UPDATE_INTERVAL);
  updateHistory();
  updateStats();
  updatePrediction();
};

init();
   
        </script>
 </body>
</html>