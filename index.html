<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>𝐓𝐇𝐄 𝐋𝐒𝐑 𝐏𝐑𝐄𝐃𝐈𝐂𝐓𝐎𝐑 𝐕.4 - AI Future Thinker and Learner</title>
  <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600;700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Outfit', sans-serif;
      background: linear-gradient(135deg, #080808, #121212, #1a1a1a, #080808, #00ffcc, #00997a, #080808);
      background-size: 100% 100%;
      color: #d8d8d8;
      margin: 0;
      padding: 12px;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
      overflow-x: hidden;
    }

    .container {
      max-width: 500px;
      width: 100%;
      background: rgba(24, 24, 24, 0.95);
      border-radius: 14px;
      padding: 16px;
      box-shadow: 0 4px 18px rgba(0, 255, 204, 0.2);
    }

    .header {
      text-align: center;
      font-size: 26px;
      font-weight: 700;
      color: #00ffcc;
      margin-bottom: 16px;
      text-shadow: 0 0 8px rgba(0, 255, 204, 0.6);
      letter-spacing: 0.7px;
    }

    .card {
      background: rgba(30, 30, 30, 0.95);
      border-radius: 12px;
      padding: 14px;
      margin-bottom: 16px;
      text-align: center;
      box-shadow: 0 3px 12px rgba(0, 255, 204, 0.15);
    }

    #currentPeriod {
      font-size: 16px;
      font-weight: 600;
      color: #ffffff;
    }

    #liveTime {
      font-size: 12px;
      color: #b0b0b0;
      margin-top: 6px;
    }

    .prediction-box {
      background: linear-gradient(135deg, #00ffcc, #00997a);
      color: #080808;
      font-size: 18px;
      font-weight: 600;
      padding: 12px;
      border-radius: 10px;
      margin-top: 12px;
      box-shadow: 0 0 10px rgba(0, 255, 204, 0.4);
    }

    .confidence {
      font-size: 11px;
      margin-top: 8px;
      color: #ffffff;
      opacity: 0.8;
    }

    .history-container, .pred-history-container {
      background: rgba(30, 30, 30, 0.95);
      border-radius: 12px;
      padding: 12px;
      box-shadow: 0 3px 12px rgba(0, 255, 204, 0.15);
      margin-bottom: 16px;
      overflow-x: hidden;
    }

    .pred-history-container {
      max-width: 450px;
      overflow-y: auto;
    }

    .history-container {
      max-width: 450px;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin: 0;
      font-size: 11px;
      table-layout: fixed;
    }

    th, td {
      padding: 8px;
      text-align: center;
      border-bottom: 1px solid rgba(48, 48, 48, 0.6);
      vertical-align: middle;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    th:first-child, td:first-child {
      overflow: visible;
      text-overflow: clip;
    }

    th {
      background-color: #1e1e1e;
      color: #00ffcc;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.4px;
      position: sticky;
      top: 0;
      z-index: 1;
    }

    tr:nth-child(even) {
      background: rgba(30, 30, 30, 0.6);
    }

    .dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      display: inline-block;
    }

    .dot.red { background: #ff5252; }
    .dot.green { background: #00ff7f; }
    .dot.violet { background: #c94dff; }

    .num.red { color: #ff5252; font-weight: 700; }
    .num.green { color: #00ff7f; font-weight: 700; }
    .num.violet { color: #c94dff; font-weight: 700; }

    .status-circle {
      display: inline-flex;
      justify-content: center;
      align-items: center;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      font-size: 12px;
      font-weight: 700;
      color: #080808;
      text-align: center;
    }

    .status-circle.win {
      background: #00ff7f;
      box-shadow: 0 0 8px rgba(0, 255, 127, 0.5);
    }

    .status-circle.loss {
      background: #ff5252;
      box-shadow: 0 0 8px rgba(255, 82, 82, 0.5);
    }

    .status-circle.pending {
      background: #b0b0b0;
      width: 20px;
      height: 20px;
      font-size: 10px;
      box-shadow: 0 0 4px rgba(176, 176, 176, 0.5);
    }

    .winnings-box {
      display: inline-block;
      background: linear-gradient(135deg, #00ffcc, #00997a);
      padding: 8px 16px;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 700;
      color: #080808;
      box-shadow: 0 2px 10px rgba(0, 255, 204, 0.4);
      width: 180px;
      text-align: center;
      line-height: 1.5;
    }

    .winnings-box span {
      color: #080808;
    }

    .stats {
      text-align: center;
      margin-bottom: 16px;
      font-size: 16px;
      color: #ffffff;
      animation: pulse 2.5s infinite;
    }

    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }

    .tab-buttons {
      display: flex;
      justify-content: center;
      margin-bottom: 16px;
    }

    .tab-button {
      background: rgba(24, 24, 24, 0.95);
      border: none;
      color: #d8d8d8;
      padding: 8px 16px;
      cursor: pointer;
      font-size: 14px;
      margin: 0 4px;
      border-radius: 8px;
      touch-action: manipulation;
    }

    .tab-button.active {
      background: linear-gradient(135deg, #00ffcc, #00997a);
      color: #080808;
    }

    .tab-content {
      display: none;
    }

    .loader {
      text-align: center;
      padding: 10px;
      color: #00ffcc;
      font-size: 12px;
    }

    #gameHistoryLoader {
      display: none;
    }

    @media (max-width: 480px) {
      .container { max-width: 100%; padding: 12px; }
      .header { font-size: 24px; }
      .card { padding: 12px; }
      th, td { padding: 6px; font-size: 10px; }
      .prediction-box { font-size: 16px; }
      .tab-button { padding: 6px 12px; font-size: 13px; }
      .winnings-box {
        font-size: 14px;
        padding: 6px 12px;
        width: 160px;
      }
      .status-circle { width: 20px; height: 20px; font-size: 10px; }
      .status-circle.pending { width: 16px; height: 16px; font-size: 8px; }
      .pred-history-container, .history-container { max-width: 100%; }
    }

    @media (min-width: 481px) {
      .container { max-width: 550px; }
      .header { font-size: 28px; }
      #currentPeriod { font-size: 17px; }
      .prediction-box { font-size: 20px; }
      th, td { font-size: 11px; }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">𝐓𝐇𝐄 𝐋𝐒𝐑 𝐏𝐑𝐄𝐃𝐈𝐂𝐓𝐎𝐑 𝐕.4</div>

    <div class="card">
      <div id="currentPeriod">Current Period: Loading...</div>
      <div id="liveTime">Time: --:--:--</div>
      <div class="prediction-box" id="predictionBox">Analyzing...</div>
      <div class="confidence" id="confidenceLevel">Confidence: Calculating...</div>
    </div>

    <div class="stats" id="accuracyStats">
      <span class="winnings-box">Winnings: <span id="winsCount">0</span>/<span id="totalCount">0</span> (<span id="accuracyPercent">0</span>%)</span>
    </div>

    <div class="tab-buttons">
      <button class="tab-button active" onclick="openTab('predHistory')">Prediction History</button>
      <button class="tab-button" onclick="openTab('gameHistory')">Game History</button>
    </div>

    <div id="predHistory" class="pred-history-container tab-content">
      <table>
        <thead>
          <tr>
            <th style="width: 35%;">Period</th>
            <th style="width: 15%;">Pred.</th>
            <th style="width: 15%;">Actual</th>
            <th style="width: 15%;">Pattern</th>
            <th style="width: 8%;">Status</th>
          </tr>
        </thead>
        <tbody id="predHistoryTable">
          <tr><td colspan="5">Loading...</td></tr>
        </tbody>
      </table>
      <div id="predHistoryLoader" class="loader">Loading more...</div>
    </div>

    <div id="gameHistory" class="history-container tab-content">
      <table>
        <thead>
          <tr>
            <th style="width: 35%;">Period</th>
            <th style="width: 20%;">Num</th>
            <th style="width: 20%;">B/S</th>
            <th style="width: 25%;">Color</th>
          </tr>
        </thead>
        <tbody id="historyTable">
          <tr><td colspan="4">Loading...</td></tr>
        </tbody>
      </table>
      <div id="gameHistoryLoader" class="loader">Loading more...</div>
    </div>
  </div>

  <script>
    const CURRENT_API = 'https://api.bdg88zf.com/api/webapi/GetGameIssue';
    const HISTORY_API = 'https://draw.ar-lottery01.com/WinGo/WinGo_1M/GetHistoryIssuePage.json';

    const REQUEST_DATA = {
      typeId: 1,
      language: 0,
      random: "e7fe6c090da2495ab8290dac551ef1ed",
      signature: "1F390E2B2D8A55D693E57FD905AE73A7",
      timestamp: 1723726679
    };

    const STORAGE_KEY = 'quantum_pulse_predictions';
    const MODEL_KEY = 'quantum_pulse_model';
    const PERFORMANCE_KEY = 'mode_performance';
    const HISTORY_KEY = 'game_history';
    const MAX_PREDICTIONS = 2880;
    const BATCH_SIZE = 20;

    let predictionModel = {
      bigsmall: {
        weights: {
          streak: 0.25,
          frequency: 0.2,
          transition: 0.2,
          zigzag: 0.15,
          trend: 0.1,
          color: 0.1,
          entropy: 0.1,
          momentum: 0.05,
          variance: 0.05,
          breaker: 0.05
        },
        performanceHistory: []
      },
      learningRate: 0.05,
      adjustWeights: function(mode, success, patternType) {
        const model = this[mode];
        model.performanceHistory.push({ success, pattern: patternType });
        if (model.performanceHistory.length > 20) model.performanceHistory.shift();

        const recentSuccessRate = model.performanceHistory.filter(p => p.success).length / model.performanceHistory.length;
        const boost = recentSuccessRate > 0.7 ? 1.5 : recentSuccessRate < 0.3 ? 0.5 : 1;

        if (success) {
          model.weights[patternType] += this.learningRate * boost;
          model.weights.streak += this.learningRate * 0.8 * boost;
          model.weights.frequency += this.learningRate * 0.6 * boost;
          model.weights.momentum += this.learningRate * 0.5 * boost;
        } else {
          model.weights.transition += this.learningRate * 1.0 * boost;
          model.weights.zigzag += this.learningRate * 0.9 * boost;
          model.weights.entropy += this.learningRate * 0.7 * boost;
          model.weights.breaker += this.learningRate * 1.2 * boost;
        }

        const total = Object.values(model.weights).reduce((a, b) => a + b, 0);
        for (let key in model.weights) {
          model.weights[key] = model.weights[key] / total;
        }
        saveModel();
      }
    };

    function loadModel() {
      const saved = localStorage.getItem(MODEL_KEY);
      if (saved) {
        const parsed = JSON.parse(saved);
        predictionModel.bigsmall.weights = parsed.bigsmall?.weights || predictionModel.bigsmall.weights;
        predictionModel.bigsmall.performanceHistory = parsed.bigsmall?.performanceHistory || [];
      }
    }

    function saveModel() {
      localStorage.setItem(MODEL_KEY, JSON.stringify({
        bigsmall: {
          weights: predictionModel.bigsmall.weights,
          performanceHistory: predictionModel.bigsmall.performanceHistory
        }
      }));
    }

    function loadPerformance() {
      return JSON.parse(localStorage.getItem(PERFORMANCE_KEY)) || {
        bigsmall: { wins: 0, total: 0, accuracy: 0 }
      };
    }

    function savePerformance(performance) {
      localStorage.setItem(PERFORMANCE_KEY, JSON.stringify(performance));
    }

    function getBigSmall(num) {
      return num >= 5 ? 'BIG' : 'SMALL';
    }

    function getColor(num) {
      if ([1, 3, 7, 9].includes(num)) return 'Green';
      if ([2, 4, 6, 8].includes(num)) return 'Red';
      if (num === 0) return 'Red/Violet';
      if (num === 5) return 'Green/Violet';
      return 'Violet';
    }

    function calculateEntropy(numbers) {
      const counts = {};
      numbers.forEach(n => counts[n] = (counts[n] || 0) + 1);
      const probs = Object.values(counts).map(c => c / numbers.length);
      return -probs.reduce((sum, p) => sum + p * Math.log2(p), 0);
    }

    function calculateMomentum(numbers) {
      const last5 = numbers.slice(0, 5).map(n => n.number);
      const diffs = last5.slice(0, -1).map((n, i) => last5[i] - last5[i + 1]);
      const avgDiff = diffs.reduce((a, b) => a + b, 0) / diffs.length;
      return Math.abs(avgDiff) > 1 ? 0.7 : 0.3;
    }

    function predictNextNumber(numbers) {
      const n = Math.min(10, numbers.length);
      if (n < 2) return Math.floor(Math.random() * 10);
      const y = numbers.slice(0, n).reverse();
      const x = Array.from({length: n}, (_, i) => i + 1);
      const meanX = (n + 1) / 2;
      const meanY = y.reduce((a, b) => a + b, 0) / n;
      const ssxx = x.reduce((a, xi, i) => a + Math.pow(xi - meanX, 2), 0);
      const sxy = x.reduce((a, xi, i) => a + (xi - meanX) * (y[i] - meanY), 0);
      const slope = sxy / ssxx;
      const intercept = meanY - slope * meanX;
      const ssyy = y.reduce((a, yi) => a + Math.pow(yi - meanY, 2), 0);
      const r2 = Math.pow(sxy, 2) / (ssxx * ssyy || 1);
      let nextY = intercept + slope * (n + 1);
      nextY = Math.max(0, Math.min(9, nextY));
      return {predicted: Math.round(nextY), r2};
    }

    function detectPattern(sequence) {
      const last3 = sequence.slice(0, 3);
      if (new Set(last3).size === 1) return `3x ${last3[0]}`;
      if (last3[0] === last3[2] && last3[0] !== last3[1]) return `Zig-Zag`;
      return "Random";
    }

    function updateLiveTime() {
      const now = new Date();
      document.getElementById("liveTime").innerText = "Time: " + now.toLocaleTimeString('en-GB');
    }

    function loadPredictions() {
      return JSON.parse(localStorage.getItem(STORAGE_KEY)) || [];
    }

    function savePredictions(predictions) {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(predictions.slice(0, MAX_PREDICTIONS)));
    }

    function loadGameHistory() {
      return JSON.parse(localStorage.getItem(HISTORY_KEY)) || [];
    }

    function saveGameHistory(history) {
      localStorage.setItem(HISTORY_KEY, JSON.stringify(history.slice(0, MAX_PREDICTIONS)));
    }

    function analyzePatterns(history) {
      if (history.length < 5) return { prediction: "Analyzing...", confidence: 0, pattern: "None" };

      const sizes = history.map(h => getBigSmall(h.number));
      const numbers = history.map(h => h.number);

      const entropy = calculateEntropy(numbers.slice(0, 10));
      const entropyScore = entropy > 2.5 ? 0.65 : 0.35;

      const momentumScore = calculateMomentum(history);

      const mean = numbers.reduce((sum, n) => sum + n, 0) / numbers.length;
      const variance = numbers.reduce((sum, n) => sum + Math.pow(n - mean, 2), 0) / numbers.length;
      const varianceScore = Math.sqrt(variance) > 2.5 ? 0.65 : 0.35;

      const {predicted: predictedNum, r2} = predictNextNumber(numbers);
      const trendScore = r2;

      const lastSize = sizes[0];
      let streak = 1;
      for (let i = 1; i < sizes.length; i++) {
        if (sizes[i] === lastSize) streak++;
        else break;
      }

      const bigCount = sizes.filter(s => s === "BIG").length;
      const smallCount = sizes.filter(s => s === "SMALL").length;
      const frequencyScore = bigCount / history.length > 0.5 ? 0.45 : 0.55;

      let bigAfterBig = 0, smallAfterBig = 0, bigAfterSmall = 0, smallAfterSmall = 0;
      for (let i = 0; i < sizes.length - 1; i++) {
        if (sizes[i] === "BIG") {
          sizes[i + 1] === "BIG" ? bigAfterBig++ : smallAfterBig++;
        } else {
          sizes[i + 1] === "BIG" ? bigAfterSmall++ : smallAfterSmall++;
        }
      }
      const probBigAfterLast = lastSize === "BIG"
        ? bigAfterBig / (bigAfterBig + smallAfterBig || 1)
        : bigAfterSmall / (bigAfterSmall + smallAfterSmall || 1);
      const transitionScore = probBigAfterLast < 0.5 ? 0.65 : 0.35;

      let zigZagCount = 0;
      for (let i = 0; i < sizes.length - 2; i++) {
        if (sizes[i] !== sizes[i + 1] && sizes[i + 1] !== sizes[i + 2] && sizes[i] === sizes[i + 2]) zigZagCount++;
      }
      const zigZagScore = zigZagCount / (sizes.length - 2) > 0.3 ? 0.75 : 0.25;

      let ema = numbers[0];
      let alpha = 2 / (numbers.length + 1);
      for (let i = 1; i < numbers.length; i++) {
        ema = alpha * numbers[i] + (1 - alpha) * ema;
      }
      const trendScoreBS = ema >= 5 ? 0.4 : 0.6;

      const colors = history.map(h => getColor(h.number));
      const colorPattern = colors.slice(0, 3).map(c => c.split('/')[0]);
      const colorConsistency = colorPattern.every(c => c === colorPattern[0]) ? 0.8 : 0.2;

      let pattern = detectPattern(sizes);

      let weightedScore =
        (streak >= 4 ? 0.9 + (streak * 0.05) : 0.5) * predictionModel.bigsmall.weights.streak +
        frequencyScore * predictionModel.bigsmall.weights.frequency +
        transitionScore * predictionModel.bigsmall.weights.transition +
        zigZagScore * predictionModel.bigsmall.weights.zigzag +
        trendScoreBS * predictionModel.bigsmall.weights.trend +
        colorConsistency * predictionModel.bigsmall.weights.color +
        entropyScore * predictionModel.bigsmall.weights.entropy +
        momentumScore * predictionModel.bigsmall.weights.momentum +
        varianceScore * predictionModel.bigsmall.weights.variance;

      let prediction = weightedScore > 0.5 ? "SMALL" : "BIG";
      let confidence = Math.max(
        (streak >= 3 ? 0.85 + (streak * 0.05) : 0.5),
        transitionScore,
        zigZagScore,
        trendScoreBS,
        entropyScore,
        momentumScore,
        varianceScore
      );

      confidence += (zigZagScore * 0.15) + (colorConsistency * 0.05) + (entropyScore * 0.1) + (momentumScore * 0.05) + (varianceScore * 0.05);
      confidence = Math.min(0.95, Math.max(0.65, confidence));

      if (confidence < 0.7) {
        const randomFactor = Math.random();
        prediction = randomFactor < frequencyScore ? "BIG" : "SMALL";
        confidence += 0.05;
      }

      // Pattern breaker to avoid consecutive losses
      const predictions = loadPredictions();
      const lastPred = predictions.find(p => p.period === history[0]?.period);
      if (lastPred && lastPred.result === 'Loss') {
        const breakerScore = predictionModel.bigsmall.weights.breaker;
        pattern = "Breaker";
        if (Math.random() < breakerScore * 10) {
          prediction = prediction === "BIG" ? "SMALL" : "BIG";
        }
        confidence = Math.min(0.95, confidence + breakerScore * 100);
      }

      return {
        prediction,
        confidence: Math.round(confidence * 100),
        pattern
      };
    }

    let predDisplayCount = BATCH_SIZE;
    let gameDisplayCount = 10;

    function renderPredictionRows(predictions, start, count) {
      const tbody = document.getElementById("predHistoryTable");
      const slice = predictions.slice(start, start + count);
      slice.forEach(item => {
        const status = item.result === 'Win' ? '<span class="status-circle win">W</span>' :
                       item.result === 'Loss' ? '<span class="status-circle loss">L</span>' :
                       '<span class="status-circle pending">P</span>';
        tbody.innerHTML += `
          <tr>
            <td>${item.period}</td>
            <td>${item.predicted}</td>
            <td>${item.actual || 'Pending'}</td>
            <td>${item.pattern || '-'}</td>
            <td>${status}</td>
          </tr>
        `;
      });
      return slice.length;
    }

    function renderGameHistoryRows(history) {
      const tbody = document.getElementById("historyTable");
      const slice = history.slice(0, 10);
      slice.forEach(item => {
        const colors = item.color.split('/');
        const dots = colors.map(c => `<span class="dot ${c.toLowerCase()}"></span>`).join('');
        const primaryClass = colors[0].toLowerCase();
        tbody.innerHTML += `
          <tr>
            <td>${item.period}</td>
            <td class="num ${primaryClass}">${item.number}</td>
            <td>${item.size}</td>
            <td>${dots}</td>
          </tr>
        `;
      });
      return slice.length;
    }

    function crossCheckPrediction(prediction, history) {
      const latestHistory = history[0];
      if (!latestHistory) return true;
      const lastPeriod = latestHistory.period;
      const predictions = loadPredictions();
      const prevPrediction = predictions.find(p => p.period === lastPeriod);
      if (prevPrediction && prevPrediction.actual) {
        const isCorrect = prevPrediction.predicted === prevPrediction.actual;
        if (!isCorrect) {
          prediction.confidence = Math.max(0.5, prediction.confidence - 10);
        }
      }
      return true;
    }

    function updatePredictionHistory(currentPeriod, history, prediction, confidence) {
      let predictions = loadPredictions();
      let performance = loadPerformance();
      let gameHistory = loadGameHistory();

      history.forEach(item => {
        if (!gameHistory.some(h => h.period === item.period)) {
          gameHistory.unshift(item);
        }
      });
      saveGameHistory(gameHistory);

      const existing = predictions.find(p => p.period === currentPeriod);
      if (!existing && currentPeriod && crossCheckPrediction(prediction, history)) {
        predictions.unshift({
          period: currentPeriod,
          predicted: prediction.prediction,
          confidence: confidence,
          actual: null,
          result: null,
          pattern: prediction.pattern
        });
      }

      history.forEach(item => {
        const pred = predictions.find(p => p.period === item.period);
        if (pred && !pred.actual) {
          pred.actual = item.size;
          const isWin = pred.predicted === pred.actual;
          pred.result = isWin ? 'Win' : 'Loss';
          let patternType = 'streak';
          const lowerPattern = pred.pattern.toLowerCase();
          if (lowerPattern.includes('zig-zag')) patternType = 'zigzag';
          else if (lowerPattern.includes('sequence')) patternType = 'trend';
          else if (lowerPattern.includes('random')) patternType = 'entropy';
          else if (lowerPattern.includes('3x')) patternType = 'streak';
          else if (lowerPattern.includes('breaker')) patternType = 'breaker';
          predictionModel.adjustWeights('bigsmall', isWin, patternType);

          performance.bigsmall.total++;
          if (isWin) performance.bigsmall.wins++;
          performance.bigsmall.accuracy = Math.round((performance.bigsmall.wins / performance.bigsmall.total) * 100);
        }
      });

      savePredictions(predictions);
      savePerformance(performance);

      const verified = predictions.filter(p => p.actual);
      const wins = verified.filter(p => p.result === 'Win').length;
      const accuracy = verified.length ? Math.round((wins / verified.length) * 100) : 0;

      document.getElementById("winsCount").innerText = wins;
      document.getElementById("totalCount").innerText = verified.length;
      document.getElementById("accuracyPercent").innerText = accuracy;

      const predTbody = document.getElementById("predHistoryTable");
      predTbody.innerHTML = predictions.length ? '' : '<tr><td colspan="5">No predictions available</td></tr>';
      predDisplayCount = BATCH_SIZE;
      renderPredictionRows(predictions, 0, predDisplayCount);
      document.getElementById("predHistoryLoader").style.display = predDisplayCount >= predictions.length ? 'none' : 'block';

      const historyTbody = document.getElementById("historyTable");
      historyTbody.innerHTML = gameHistory.length ? '' : '<tr><td colspan="4">No history available</td></tr>';
      renderGameHistoryRows(gameHistory);
      document.getElementById("gameHistoryLoader").style.display = 'none';
    }

    async function fetchData() {
      try {
        const periodRes = await fetch(CURRENT_API, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(REQUEST_DATA)
        });
        const periodData = await periodRes.json();
        const currentPeriod = periodData?.data?.issueNumber || "Unavailable";
        document.getElementById("currentPeriod").innerText = `Current Period: ${currentPeriod}`;

        const res = await fetch(HISTORY_API + '?ts=' + Date.now());
        const data = await res.json();
        const history = data.data.list.map(item => {
          const num = parseInt(item.number);
          const color = getColor(num);
          return {
            period: item.issueNumber,
            number: num,
            size: getBigSmall(num),
            color
          };
        });

        const prediction = analyzePatterns(history);
        document.getElementById("predictionBox").innerText = `Prediction → ${prediction.prediction}`;
        document.getElementById("confidenceLevel").innerText = `Confidence: ${prediction.confidence}%`;

        updatePredictionHistory(currentPeriod, history, prediction, prediction.confidence);

      } catch (error) {
        document.getElementById("predictionBox").innerText = "Prediction Error";
        document.getElementById("confidenceLevel").innerText = "Confidence: N/A";
      }
    }

    function openTab(tabId) {
      const tabContents = document.getElementsByClassName('tab-content');
      for (let i = 0; i < tabContents.length; i++) {
        tabContents[i].style.display = 'none';
      }
      document.getElementById(tabId).style.display = 'block';

      const buttons = document.getElementsByClassName('tab-button');
      for (let i = 0; i < buttons.length; i++) {
        buttons[i].classList.remove('active');
      }
      event.currentTarget.classList.add('active');
    }

    const predObserver = new IntersectionObserver((entries) => {
      if (entries[0].isIntersecting) {
        const predictions = loadPredictions();
        if (predDisplayCount < predictions.length) {
          const added = renderPredictionRows(predictions, predDisplayCount, BATCH_SIZE);
          predDisplayCount += added;
          document.getElementById("predHistoryLoader").style.display = predDisplayCount >= predictions.length ? 'none' : 'block';
        } else {
          document.getElementById("predHistoryLoader").style.display = 'none';
        }
      }
    }, { threshold: 0.1 });

    async function fetchAndStoreHistory() {
      try {
        const res = await fetch(HISTORY_API + '?ts=' + Date.now());
        const data = await res.json();
        const history = data.data.list.map(item => {
          const num = parseInt(item.number);
          const color = getColor(num);
          return {
            period: item.issueNumber,
            number: num,
            size: getBigSmall(num),
            color
          };
        });
        localStorage.setItem('game_history', JSON.stringify(history));
      } catch (error) {
        console.error('Error fetching game history:', error);
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      localStorage.clear();
      predObserver.observe(document.getElementById('predHistoryLoader'));
      fetchAndStoreHistory();
    });

    setInterval(updateLiveTime, 1000);
    setInterval(fetchData, 4000);
    fetchData();
    updateLiveTime();
    document.getElementById('predHistory').style.display = 'block';
  </script>
</body>
</html>                                                         
