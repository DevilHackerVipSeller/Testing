<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>𝐃𝐄𝐕𝐈𝐋 𝐇𝐀𝐂𝐊𝐄𝐑 𝐅𝐀𝐌𝐈𝐋𝐘</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;500;700&family=Orbitron:wght@400;600&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
    @keyframes gradientShift { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } }
    @keyframes ripple { 0% { transform: scale(0); opacity: 0.5; } 100% { transform: scale(4); opacity: 0; } }

    .ripple-button {
      position: relative;
      overflow: hidden;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    .ripple-button:hover {
      transform: translateY(-3px);
      box-shadow: 0 6px 16px rgba(45, 212, 191, 0.3);
    }
    .ripple-button:active {
      transform: scale(0.98);
    }
    .ripple-button::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(45, 212, 191, 0.4);
      border-radius: 50%;
      transform: scale(0);
      opacity: 0;
      pointer-events: none;
      z-index: 1;
    }
    .ripple-button.ripple-effect::after {
      animation: ripple 0.5s ease-out;
    }

    body {
      background: linear-gradient(to right, #1E1B4B, #2E1065, #1E1B4B);
      background-size: 200% 200%;
      animation: gradientShift 20s ease infinite;
      font-family: 'Poppins', sans-serif;
      color: #F5F5F5;
      min-h-screen;
      padding: 1.5rem;
    }

    .container {
      max-width: 28rem;
      margin: 0 auto;
      padding: 0 0.5rem;
    }

    .wrapper svg {
      width: 100%;
      height: 100%;
      max-height: 60px;
      filter: drop-shadow(0 0 8px rgba(45, 212, 191, 0.4));
    }
    .wrapper svg text {
      font-size: 10px;
      font-family: 'Orbitron', sans-serif;
      fill: #2DD4BF;
      stroke: #F472B6;
      stroke-width: 0.5;
      text-shadow: 0 0 12px rgba(45, 212, 191, 0.5);
      animation: pulse 2s ease-in-out infinite;
    }

    .toast {
      position: fixed;
      top: 1rem;
      right: 1rem;
      left: 1rem;
      background: rgba(30, 27, 75, 0.95);
      color: #2DD4BF;
      padding: 0.75rem 1rem;
      border-radius: 0.5rem;
      border: 1px solid #2DD4BF;
      opacity: 0;
      transition: opacity 0.3s ease;
      z-index: 1000;
      box-shadow: 0 4px 12px rgba(45, 212, 191, 0.2);
      font-size: 0.875rem;
      text-align: center;
    }
    .toast.show { opacity: 1; }

    .card {
      background: linear-gradient(135deg, #2E1065, #1E1B4B);
      border-radius: 0.75rem;
      border: 1px solid rgba(45, 212, 191, 0.2);
      padding: 1rem;
      margin-bottom: 1.5rem;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    .card:hover {
      transform: translateY(-4px);
      box-shadow: 0 8px 20px rgba(45, 212, 191, 0.3);
    }

    .gradient-button {
      background: linear-gradient(to right, #2DD4BF, #F472B6);
      border: none;
      border-radius: 0.5rem;
      padding: 0.5rem 1rem;
      font-size: 0.875rem;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: #1E1B4B;
      box-shadow: 0 4px 12px rgba(45, 212, 191, 0.3);
      transition: all 0.3s ease;
    }
    .gradient-button:hover {
      background: linear-gradient(to right, #F472B6, #2DD4BF);
      box-shadow: 0 6px 16px rgba(45, 212, 191, 0.5);
      transform: translateY(-2px);
    }

    .history-item {
      background: linear-gradient(135deg, #2E1065, #1E1B4B);
      border-radius: 0.5rem;
      padding: 0.75rem;
      transition: all 0.3s ease;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }
    .history-item:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(45, 212, 191, 0.25);
    }

    .no-results {
      border: 2px solid #F87171;
      text-align: center;
      color: #F87171;
      padding: 0.75rem;
      border-radius: 0.5rem;
      font-size: 0.875rem;
    }

    .panel {
      background: rgba(30, 27, 75, 0.9);
      border-radius: 0.5rem;
      padding: 0.75rem;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }

    @media (max-width: 640px) {
      .container { padding: 0 0.5rem; }
      .wrapper svg text { font-size: 8px; }
      .card { padding: 0.75rem; }
      .toast { top: 0.75rem; font-size: 0.75rem; }
      .gradient-button { font-size: 0.75rem; padding: 0.4rem 0.8rem; }
    }
  </style>
</head>
<body class="min-h-screen p-4">
  <div class="container space-y-6">
    <div class="wrapper">
      <svg role="img" viewBox="0 0 10 20" preserveAspectRatio="xMidYMid meet">
        <text x="50%" y="50%" dy=".1em" text-anchor="middle" font-size="80">
          𝐃𝐄𝐕𝐈𝐋 𝐇𝐀𝐂𝐊𝐄𝐑 𝐅𝐀𝐌𝐈𝐋𝐘
        </text>
      </svg>
    </div>

    <div class="card">
      <div class="flex items-center justify-between mb-3">
        <h2 class="text-lg font-bold text-teal-400 flex items-center font-orbitron">
          <i class="fa-solid fa-brain mr-2"></i> Current Predictor
        </h2>
        <button onclick="refreshPrediction()" class="ripple-button gradient-button font-semibold flex items-center">
          <i class="fa-solid fa-sync-alt mr-1"></i> Refresh
        </button>
      </div>
      <div class="panel text-center">
        <div class="text-teal-300 mb-2 text-sm">PERIOD: <span id="currentPeriodDisplay">-</span></div>
        <div class="text-teal-300 mb-2 text-sm">TIMER: <span id="timerDisplay">0 0 : 0 0</span></div>
        <div id="currentPredictionDisplay" class="text-xl font-bold text-white mb-1">-</div>
        <div class="text-white text-sm">CONFIDENCE: <span id="confidenceDisplay">0%</span></div>
      </div>
    </div>

    <div class="card">
      <h2 class="text-lg font-bold text-teal-400 mb-3 font-orbitron">══✿ Analysis Dashboard ✿══</h2>
      <div class="grid grid-cols-2 gap-3">
        <div class="panel text-center">
          <div class="text-teal-300 text-sm">Total Wins</div>
          <div id="totalWins" class="text-lg font-bold text-white">0</div>
        </div>
        <div class="panel text-center">
          <div class="text-teal-300 text-sm">Total Losses</div>
          <div id="totalLosses" class="text-lg font-bold text-white">0</div>
        </div>
        <div class="panel text-center">
          <div class="text-teal-300 text-sm">CONFIDENCE</div>
          <div id="overallConfidenceDisplay" class="text-white">0%</div>
        </div>
        <div class="panel text-center">
          <div class="text-teal-300 text-sm">Server Status</div>
          <div id="serverStatus" class="text-lg font-bold text-white">Connecting</div>
        </div>
      </div>
    </div>

    <div class="card">
      <h2 class="text-lg font-bold text-teal-400 mb-3 font-orbitron">━━━━━━◆ History ◆━━━━━━</h2>
      <div id="historyContainer" class="space-y-3"></div>
    </div>
  </div>

  <div id="toastContainer" class="toast"></div>

  <script>
  // Configuration Constants
const API_URL = "https://api.fantasygamesapi.com/api/webapi/GetNoaverageEmerdList";
const API_RETRY_INTERVAL = 5000;
const API_MAX_RETRIES = 3;
const UPDATE_INTERVAL = 5000;
const SMALL_NUMBERS = [5, 6, 7, 8, 9];
const BIG_NUMBERS = [0, 1, 2, 3, 4];
const MAX_HISTORY = 50;
const TOAST_COOLDOWN = 1500;

// DOM Elements Cache
const DOM = {
  toastContainer: document.getElementById("toastContainer"),
  currentPeriodDisplay: document.getElementById("currentPeriodDisplay"),
  timerDisplay: document.getElementById("timerDisplay"),
  currentPredictionDisplay: document.getElementById("currentPredictionDisplay"),
  confidenceDisplay: document.getElementById("confidenceDisplay"),
  totalWins: document.getElementById("totalWins"),
  totalLosses: document.getElementById("totalLosses"),
  overallConfidenceDisplay: document.getElementById("overallConfidenceDisplay"),
  serverStatus: document.getElementById("serverStatus"),
  historyContainer: document.getElementById("historyContainer"),
  resetButton: document.getElementById("resetButton") // Added reset button
};

// Validate DOM elements
Object.values(DOM).forEach((el, index) => {
  if (!el && index !== 8) console.error(`DOM element at index ${index} is null. Check HTML IDs.`);
});

// State
let historyData = JSON.parse(localStorage.getItem('spyPredictorHistory')) || [];
let lastFetchedPeriod = null;
let lastPrediction = null;
let stats = JSON.parse(localStorage.getItem('spyPredictorStats')) || { wins: 0, losses: 0 };
let isFetching = false;
let lastPeriodUpdate = null;
let lastToastTime = 0;

// Utility Functions
const showToast = (message, type = "info", duration = 1500) => {
  const now = Date.now();
  if (now - lastToastTime < TOAST_COOLDOWN) return;
  lastToastTime = now;
  if (!DOM.toastContainer) return console.error("Toast container not found");
  DOM.toastContainer.textContent = message;
  DOM.toastContainer.className = `toast show ${type}`;
  setTimeout(() => DOM.toastContainer.className = "toast", duration);
};

const formatPeriodNumber = () => {
  const now = new Date();
  now.setTime(now.getTime() + (now.getTimezoneOffset() + 5.5 * 60) * 60 * 1000);
  const yearMonthDay = now.toISOString().slice(0, 10).replace(/-/g, '');
  const minutes = now.getHours() * 60 + now.getMinutes();
  return yearMonthDay + "1000" + (10001 + minutes).toString();
};

const pad = (num) => num.toString().padStart(2, '0');

const formatTimer = () => {
  const now = new Date();
  now.setTime(now.getTime() + (now.getTimezoneOffset() + 5.5 * 60) * 60 * 1000);
  const seconds = now.getSeconds();
  const remainingSeconds = 60 - seconds;
  return `${pad(0)} : ${pad(remainingSeconds)}`.replace(/(\d)(?=\d)/g, '$1 ');
};

// Function to determine bet level based on confidence
const getBetLevel = (confidence) => {
  if (confidence >= 95) return "4x";
  if (confidence >= 80) return "3x";
  if (confidence >= 60) return "2x";
  return "1x";
};

// Enhanced Prediction Logic
const spyPredict = (history) => {
  console.log("spyPredict called with history:", history);
  if (history.length < 5) {
    const prediction = Math.random() < 0.5 ? "BIG" : "SMALL";
    return { prediction, confidence: 50, betLevel: "1x", decisionFactor: "Random (insufficient data)" };
  }

  // Filter valid results
  const recentResults = history
    .filter(h => h.result !== "-" && !isNaN(Number(h.result)) && Number(h.result) >= 0 && Number(h.result) <= 9)
    .slice(0, 15)
    .map(h => Number(h.result))
    .reverse();

  if (recentResults.length < 3) {
    const prediction = Math.random() < 0.5 ? "SMALL" : "BIG";
    return { prediction, confidence: 50, betLevel: "1x", decisionFactor: "Random (no valid historical data)" };
  }

  // Calculate basic metrics
  const bigCount = recentResults.filter(num => num >= 5).length;
  const totalCount = recentResults.length || 1;
  const probBig = bigCount / totalCount;

  // Weighted moving average
  const weights = [0.4, 0.3, 0.2, 0.1];
  const recent4 = recentResults.slice(0, 4);
  const weightedBig = recent4.reduce((sum, num, i) => sum + (num >= 5 ? weights[i] : 0), 0);
  const weightedTrend = weightedBig / weights.reduce((a, b) => a + b, 0);

  // Analyze streaks
  let streakType = null;
  let streakLength = 1;
  for (let i = 1; i < recentResults.length; i++) {
    const currentType = recentResults[i] >= 5 ? "BIG" : "SMALL";
    const prevType = recentResults[i - 1] >= 5 ? "BIG" : "SMALL";
    if (currentType === prevType) {
      streakLength++;
      streakType = currentType;
    } else {
      break;
    }
  }

  // Analyze alternations
  let alternationCount = 0;
  for (let i = 2; i < recentResults.length; i++) {
    const type1 = recentResults[i] >= 5 ? "BIG" : "SMALL";
    const type2 = recentResults[i - 1] >= 5 ? "BIG" : "SMALL";
    const type3 = recentResults[i - 2] >= 5 ? "BIG" : "SMALL";
    if (type1 !== type2 && type2 !== type3) alternationCount++;
  }
  const alternationRatio = alternationCount / (recentResults.length - 2) || 0;

  // Pattern analysis: BIG/SMALL transitions
  let transitionCount = 0;
  for (let i = 1; i < recentResults.length; i++) {
    const currentType = recentResults[i] >= 5 ? "BIG" : "SMALL";
    const prevType = recentResults[i - 1] >= 5 ? "BIG" : "SMALL";
    if (currentType !== prevType) transitionCount++;
  }
  const transitionRatio = transitionCount / (recentResults.length - 1) || 0;

  // Decision logic
  let prediction;
  let confidence;
  let decisionFactor = [];

  if (streakLength >= 4) {
    prediction = streakType === "BIG" ? "SMALL" : "BIG";
    confidence = Math.min(90, 70 - streakLength * 4);
    decisionFactor.push(`Long streak of ${streakType} (${streakLength} times)`);
  } else if (alternationRatio > 0.6) {
    const lastType = recentResults[0] >= 5 ? "BIG" : "SMALL";
    prediction = lastType === "BIG" ? "SMALL" : "BIG";
    confidence = Math.min(92, 75 + alternationRatio * 20);
    decisionFactor.push(`High alternation ratio: ${alternationRatio.toFixed(2)}`);
  } else if (transitionRatio > 0.5 && weightedTrend < 0.4) {
    prediction = "BIG";
    confidence = Math.min(88, 65 + transitionRatio * 20);
    decisionFactor.push(`High transition ratio: ${transitionRatio.toFixed(2)}, weighted trend: ${weightedTrend.toFixed(2)}`);
  } else if (transitionRatio > 0.5 && weightedTrend > 0.6) {
    prediction = "SMALL";
    confidence = Math.min(88, 65 + transitionRatio * 20);
    decisionFactor.push(`High transition ratio: ${transitionRatio.toFixed(2)}, weighted trend: ${weightedTrend.toFixed(2)}`);
  } else {
    prediction = probBig < 0.5 ? "BIG" : "SMALL";
    confidence = Math.round(60 + Math.abs(probBig - 0.5) * 100);
    decisionFactor.push(`Recent BIG ratio: ${probBig.toFixed(2)}`);
  }

  // Adjust confidence based on historical win rate
  if (history.length >= 15) {
    const recentPredictions = history.slice(0, 15).filter(h => h.resultStatus === "WIN");
    const winRate = recentPredictions.length / 15;
    confidence = Math.min(95, confidence + winRate * 15);
    decisionFactor.push(`Recent win rate: ${winRate.toFixed(2)}`);
  }

  const betLevel = getBetLevel(confidence);
  decisionFactor = decisionFactor.join(", ");

  console.log("Prediction:", { prediction, confidence, betLevel, decisionFactor });
  return { prediction, confidence, betLevel, decisionFactor };
};

const updateLastStatus = (actualNumber) => {
  console.log("updateLastStatus called with actualNumber:", actualNumber, "lastPrediction:", lastPrediction);
  if (!lastPrediction) return "Pending";
  const actualType = actualNumber >= 5 ? "BIG" : "SMALL";
  const status = lastPrediction === actualType ? "WIN" : "LOSS";
  stats[status === "WIN" ? "wins" : "losses"]++;
  localStorage.setItem('spyPredictorStats', JSON.stringify(stats));
  console.log("Updated stats:", stats);
  return status;
};

const saveHistory = () => {
  historyData = historyData.slice(0, MAX_HISTORY);
  try {
    localStorage.setItem('spyPredictorHistory', JSON.stringify(historyData));
    console.log("History saved:", historyData);
  } catch (e) {
    showToast("Warning: Failed to save history.", "warning");
    console.error("History save error:", e);
  }
};

const fetchGameResult = async (retryCount = 0) => {
  if (isFetching) {
    console.log("Fetch skipped: already fetching");
    return null;
  }
  isFetching = true;
  DOM.serverStatus.innerText = `Connecting (Attempt ${retryCount + 1})`;
  DOM.currentPredictionDisplay.innerHTML = '<i class="fa fa-spinner spinner"></i>';
  try {
    const response = await fetch(API_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        pageSize: 10,
        pageNo: 1,
        typeId: 1,
        language: 0,
        random: "4a0522c6ecd8410496260e686be2a57c",
        signature: "334B5E70A0C9B8918B0B15E517E2069C",
        timestamp: Math.floor(Date.now() / 1000)
      })
    });
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    console.log("Raw API response:", data);
    if (!data?.data?.list?.length || !data.data.list[0].issueNumber || !data.data.list[0].number || isNaN(Number(data.data.list[0].number)) || Number(data.data.list[0].number) < 0 || Number(data.data.list[0].number) > 9) {
      throw new Error("Invalid API response: empty list or missing/invalid issueNumber/number");
    }
    DOM.serverStatus.innerText = "Connected";
    showToast("Fetched game data.", "success");
    console.log("API Result:", data.data.list[0]);
    return data.data.list[0];
  } catch (e) {
    console.error("API Error:", e.message, "Retry count:", retryCount);
    DOM.serverStatus.innerText = `Retry ${retryCount + 1}/${API_MAX_RETRIES}`;
    if (retryCount < API_MAX_RETRIES) {
      await new Promise(resolve => setTimeout(resolve, API_RETRY_INTERVAL));
      return fetchGameResult(retryCount + 1);
    } else {
      showToast("API failed. Using simulated data.", "error");
      console.warn("Using simulated data");
      const simulatedResult = {
        issueNumber: formatPeriodNumber(),
        number: Math.floor(Math.random() * 10).toString()
      };
      console.log("Simulated Result:", simulatedResult);
      DOM.serverStatus.innerText = "Simulated";
      return simulatedResult;
    }
  } finally {
    isFetching = false;
  }
};

const updatePrediction = async () => {
  console.log("updatePrediction called at", new Date().toISOString());
  const now = new Date();
  now.setTime(now.getTime() + (now.getTimezoneOffset() + 5.5 * 60) * 60 * 1000);
  const currentMinute = now.getHours() * 60 + now.getMinutes();
  const result = await fetchGameResult();

  if (!result) {
    console.warn("No result fetched, updating UI with existing data");
    showToast("No new data available.", "warning");
    DOM.currentPredictionDisplay.innerText = lastPrediction ? `${lastPrediction} (1x)` : "Waiting for data...";
    updateHistory();
    updateStats();
    return;
  }

  console.log("Fetched result:", result);

  // Calculate next period
  const nextPeriodFull = (BigInt(result.issueNumber) + 1n).toString();
  const nextPeriod = nextPeriodFull.slice(-3);

  // Prevent duplicate periods
  if (lastFetchedPeriod === result.issueNumber && lastPeriodUpdate === currentMinute) {
    console.log("Duplicate period detected, skipping update");
    DOM.currentPredictionDisplay.innerText = lastPrediction ? `${lastPrediction} (1x)` : "Waiting for data...";
    updateHistory();
    updateStats();
    return;
  }

  // Cross-check period to ensure no duplicates
  if (historyData.some(item => item.period === nextPeriod)) {
    console.log("Next period already in history, refreshing UI");
    DOM.currentPredictionDisplay.innerText = lastPrediction ? `${lastPrediction} (1x)` : "Waiting for data...";
    updateHistory();
    updateStats();
    return;
  }

  // Update previous period if pending
  if (historyData.length > 0 && historyData[0].resultStatus === "Pending") {
    const actualNumber = Number(result.number);
    if (isNaN(actualNumber)) {
      console.error("Invalid result number:", result.number);
      showToast("Error: Invalid API result number.", "error");
      updateHistory();
      updateStats();
      return;
    }
    const status = updateLastStatus(actualNumber);
    const resultType = actualNumber >= 5 ? "BIG" : "SMALL";
    historyData[0].result = actualNumber.toString();
    historyData[0].resultStatus = status;
    historyData[0].calculation = `${actualNumber} (${resultType})`;
    showToast(`Result: ${status} (${resultType})`, status === "WIN" ? "success" : "error");
    saveHistory();
    updateHistory();
    updateStats();
  }

  // Generate new prediction
  const aiDecision = spyPredict(historyData);
  lastPrediction = aiDecision.prediction;

  DOM.currentPeriodDisplay.innerText = nextPeriodFull;
  DOM.currentPredictionDisplay.innerText = `${aiDecision.prediction} (${aiDecision.betLevel})`;
  DOM.confidenceDisplay.innerText = `${aiDecision.confidence}%`;
  DOM.overallConfidenceDisplay.innerText = `${aiDecision.confidence}%`;

  historyData.unshift({
    period: nextPeriod,
    prediction: aiDecision.prediction,
    betLevel: aiDecision.betLevel,
    result: "-",
    resultStatus: "Pending",
    calculation: "-",
    decisionFactor: aiDecision.decisionFactor
  });
  saveHistory();
  updateHistory();
  updateStats();
  lastFetchedPeriod = result.issueNumber;
  lastPeriodUpdate = currentMinute;
};

const updateTimer = () => {
  DOM.timerDisplay.innerText = formatTimer();
  requestAnimationFrame(updateTimer);
};

const updateStats = () => {
  DOM.totalWins.innerText = stats.wins || 0;
  DOM.totalLosses.innerText = stats.losses || 0;
  console.log("Stats updated:", stats);
};

const updateHistory = () => {
  console.log("Updating history with data:", JSON.stringify(historyData, null, 2));
  if (!DOM.historyContainer) {
    console.error("History container not found");
    showToast("Error: History container not found.", "error");
    return;
  }
  if (historyData.length === 0) {
    console.warn("No history data available");
    DOM.historyContainer.innerHTML = '<div class="no-results">No results available yet. Waiting for API data...</div>';
    return;
  }
  try {
    DOM.historyContainer.innerHTML = historyData.map((item, index) => {
      let borderColor = item.resultStatus === "WIN" ? "border-l-4 border-green-400" :
                      item.resultStatus === "LOSS" ? "border-l-4 border-red-400" :
                      "border-l-4 border-yellow-400";
      let iconClass = item.resultStatus === "WIN" ? "fa-check-circle win-animation text-green-400" :
                     item.resultStatus === "LOSS" ? "fa-xmark-circle loss-animation text-red-400" :
                     "fa-spinner spinner text-yellow-400";
      return `<div class="history-item ripple grid grid-cols-3 gap-2 p-3 ${borderColor}" role="listitem">
                <div class="col-span-2 space-y-1">
                  <div class="text-cyan-200 text-sm"><i class="fa fa-calendar mr-1 text-magenta-400"></i><strong>Period: ${item.period}</strong></div>
                  <div class="text-cyan-200 text-sm"><i class="fa fa-money-bill mr-1 text-magenta-400"></i>Predict: ${item.prediction} (${item.betLevel})</div>
                  <div class="text-cyan-200 text-sm"><i class="fa fa-chart-bar mr-1 text-magenta-400"></i>Result: ${item.calculation}</div>
                  <div class="text-cyan-200 text-sm"><i class="fa fa-trophy mr-1 text-magenta-400"></i>Status: ${item.resultStatus}</div>
                </div>
                <div class="flex items-center justify-end">
                  <i class="fa-solid ${iconClass} text-lg"></i>
                  <button onclick="deleteHistoryItem(${index})" class="ml-2 text-red-600 hover:text-red-800" title="Delete">
                    <i class="fa-solid fa-trash"></i>
                  </button>
                </div>
              </div>`;
    }).join('');
  } catch (e) {
    console.error("Error updating history:", e);
    showToast("Error updating history display.", "error");
    DOM.historyContainer.innerHTML = '<div class="no-results">Error displaying history. Please try again.</div>';
  }
};

const refreshPrediction = async () => {
  showToast("Refreshing prediction...", "info");
  await updatePrediction();
};

const clearHistory = () => {
  historyData = [];
  stats.wins = 0;
  stats.losses = 0;
  saveHistory();
  localStorage.setItem('spyPredictorStats', JSON.stringify(stats));
  updateHistory();
  updateStats();
  showToast("History cleared.", "success");
};

const deleteHistoryItem = (index) => {
  if (index < 0 || index >= historyData.length) {
    showToast("Error: Invalid history item.", "error");
    return;
  }
  const item = historyData[index];
  if (item.resultStatus === "WIN") stats.wins--;
  else if (item.resultStatus === "LOSS") stats.losses--;
  historyData.splice(index, 1);
  saveHistory();
  localStorage.setItem('spyPredictorStats', JSON.stringify(stats));
  updateHistory();
  updateStats();
  showToast("History item deleted.", "success");
};

// NEW FUNCTION: Reset all data on login
const handleLogin = () => {
  // Clear all existing data
  historyData = [];
  stats = { wins: 0, losses: 0 };
  lastFetchedPeriod = null;
  lastPrediction = null;
  
  // Clear localStorage
  localStorage.removeItem('spyPredictorHistory');
  localStorage.removeItem('spyPredictorStats');
  
  // Update UI
  updateHistory();
  updateStats();
  DOM.currentPeriodDisplay.innerText = "Loading...";
  DOM.currentPredictionDisplay.innerText = "Waiting for data...";
  DOM.confidenceDisplay.innerText = "0%";
  
  showToast("Logged in. All previous data cleared.", "success");
  
  // Start fresh prediction
  updatePrediction();
};

// Initialize
const init = () => {
  console.log("Initializing application at", new Date().toISOString());
  updateTimer();
  setInterval(updatePrediction, UPDATE_INTERVAL);
  
  // Add event listener for reset button if it exists
  if (DOM.resetButton) {
    DOM.resetButton.addEventListener('click', handleLogin);
  }
  
  // Initialize with existing data
  updateHistory();
  updateStats();
  updatePrediction();
};

init();
  
      </script>
</body>
</html>